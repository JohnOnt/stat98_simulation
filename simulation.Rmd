---
title: "R Notebook"
output:
  pdf_document: default
  pdf: default
---

```{r}
lambda <- 1/900
sims <- 800
n <- 15
tsamples <- replicate(sims, rexp(n, rate = lambda))
mu = 1/lambda

results <- as.numeric(sims)
t.int <- matrix(FALSE, sims, 2)
for (i in 1:sims) {
    t.int[i, ] <- t.test(tsamples[, i], conf.level = 0.95)$conf.int
    results[i] <- t.int[i, 1] < mu & t.int[i, 2] > mu
}
sum(results)/sims
```

```{r}
# Define functions for calculating estimates (to simplify code)

# For Normal and Poisson
get_estimate_NormPois <- function(data, indices) {
  return(mean(data[indices]))
}

# For Binomial Distribution
get_estimate_Binom <- function(data, indices) {
  return(mean(data[indices])/length(data[indices]))
}

# For Geometric Distribution
get_estimate_Geom <- function(data, indices) {
  return(1/mean(data[indices]))
}
```

```{r}
# Generate Da DATA
# FIVE Distributions
# Normal, Poisson, Binomial, Geometric, ¯\_(ツ)_/¯ distribution
n <- 100
normies <- rnorm(n) # continous and normal
poissis <- rpois(n, 2) # Continuous not normal
binnies <- rbinom(n, n, 0.7) # discrete normalish
geomies <- rgeom(n, 0.7) # discrete abnormal
```

```{r}
# T-test confidence intervals
```

```{r}
library(boot)

boot_out <- boot(
  data =normies,
  statistic = get_estimate_NormPois,
  R = 100
)

boot.ci(boot_out)
boot.ci(boot_out, type = "basic") # Bias corrected bootstrap
boot.ci(boot_out, type = "perc") # Standard bootstrap 
boot.ci(boot_out, type = "norm") # Parametric (standard normal)
```
```{r}
boot.ci(boot_out)$basic[5]
```

```{r}
library(kernelboot)

b1 <- kernelboot(data=normies, statistic=get_estimate_NormPois)
summary(b1)[3]
  
```


```{r}
# Create variables
nsims = 100
n = c(10, 30, 100)
mu = 0
coverage = c()

for (i in 1:nsims) {
  
  normies10 = rnorm(10)
  
  normies10boot <- boot(
      data = normies10,
      statistic = get_estimate_NormPois,
      R = 100
  )
  
  # boot.ci(normies10boot, type = "perc")[[4]][5]
  
  lower = boot.ci(normies10boot, type = "perc")[[4]][4]
  upper = boot.ci(normies10boot, type = "perc")[[4]][5]
  
  coverage[i] = lower <= mu & upper >= mu
}

# part (i)
mean(coverage)
```

